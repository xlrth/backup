#include "CSqliteWrapper.h"

#include <assert.h>

#include "Helpers.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CStatement::CStatement(sqlite3_stmt* statement)
    :
    mStatement(statement)
{}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CStatement::CStatement(CStatement&& other)
{
    mStatement = other.mStatement;
    other.mStatement = nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CStatement::~CStatement() noexcept(false)
{
    if (mStatement != nullptr)
    {
        VERIFY(SQLITE_OK == sqlite3_finalize(mStatement));
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
bool CSqliteWrapper::CStatement::HasData()
{
    return SQLITE_ROW == sqlite3_step(mStatement);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
long long CSqliteWrapper::CStatement::ReadInt(int col)
{
// disabling assertion: fails for old format snapshots
//    assert(sqlite3_column_type(mStatement, col) == SQLITE_INTEGER);
    return sqlite3_column_int64(mStatement, col);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
std::string CSqliteWrapper::CStatement::ReadString(int col)
{
    assert(sqlite3_column_type(mStatement, col) == SQLITE_TEXT);
    return (const char*)sqlite3_column_text(mStatement, col);
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CSqliteWrapper()
    :
    mDb(nullptr)
{}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CSqliteWrapper(const std::string& path, bool readOnly)
    :
    mDb(nullptr)
{
    if (readOnly)
    {
        VERIFY(SQLITE_OK == sqlite3_open_v2(path.c_str(), &mDb, SQLITE_OPEN_READONLY, nullptr));
    }
    else
    {
        VERIFY(SQLITE_OK == sqlite3_open_v2(path.c_str(), &mDb, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, nullptr));
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CSqliteWrapper(CSqliteWrapper&& other)
    :
    mDb(other.mDb)
{
    other.mDb = nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::~CSqliteWrapper() noexcept(false)
{
    if (mDb != nullptr)
    {
        Close();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper& CSqliteWrapper::operator = (CSqliteWrapper&& other)
{
    mDb = other.mDb;
    other.mDb = nullptr;
    return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
bool CSqliteWrapper::IsOpen() const
{
    return mDb != nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void CSqliteWrapper::Close()
{
    VERIFY(mDb != nullptr);
    VERIFY(SQLITE_OK == sqlite3_close(mDb));
    mDb = nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void CSqliteWrapper::RunQuery(const std::string& query)
{
    VERIFY(mDb != nullptr);
    VERIFY(SQLITE_OK == sqlite3_exec(mDb, query.c_str(), nullptr, nullptr, nullptr));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CStatement CSqliteWrapper::StartQuery(const std::string& query)
{
    VERIFY(mDb != nullptr);
    sqlite3_stmt* statement;
    VERIFY(SQLITE_OK == sqlite3_prepare_v2(mDb, query.c_str(), -1, &statement, 0));
    return statement;
}

