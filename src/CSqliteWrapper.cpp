#include "CSqliteWrapper.h"

#include <assert.h>

#include "Helpers.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CStatement::CStatement(sqlite3_stmt* statement)
    :
    mStatement(statement)
{}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CStatement::CStatement(CStatement&& other)
{
    mStatement = other.mStatement;
    other.mStatement = nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CStatement::~CStatement()
{
    Helpers::TryCatch([this]() { Finalize(); });
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
bool CSqliteWrapper::CStatement::HasData()
{
    return SQLITE_ROW == sqlite3_step(mStatement);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
long long CSqliteWrapper::CStatement::ReadInt(int col)
{
    VERIFY(sqlite3_column_type(mStatement, col) == SQLITE_INTEGER);
    return sqlite3_column_int64(mStatement, col);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
std::string CSqliteWrapper::CStatement::ReadString(int col)
{
    VERIFY(sqlite3_column_type(mStatement, col) == SQLITE_TEXT);
    return reinterpret_cast<const char*>(sqlite3_column_text(mStatement, col));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void CSqliteWrapper::CStatement::Finalize()
{
    if (mStatement != nullptr)
    {
        VERIFY(SQLITE_OK == sqlite3_finalize(mStatement));
        mStatement = nullptr;
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CSqliteWrapper()
    :
    mSqliteHandle(nullptr)
{}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CSqliteWrapper(const CPath& path, bool readOnly)
    :
    mSqliteHandle(nullptr)
{
    int flags;
    if (readOnly)
    {
        flags = SQLITE_OPEN_READONLY;
    }
    else
    {
        flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;
    }
    VERIFY(SQLITE_OK == sqlite3_open_v2(reinterpret_cast<const char*>(path.u8string().c_str()), &mSqliteHandle, flags, nullptr));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CSqliteWrapper(CSqliteWrapper&& other)
    :
    mSqliteHandle(other.mSqliteHandle)
{
    other.mSqliteHandle = nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::~CSqliteWrapper()
{
    if (mSqliteHandle != nullptr)
    {
        Helpers::TryCatch([this]() { Close(); });
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper& CSqliteWrapper::operator = (CSqliteWrapper&& other)
{
    mSqliteHandle = other.mSqliteHandle;
    other.mSqliteHandle = nullptr;
    return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
bool CSqliteWrapper::IsOpen() const
{
    return mSqliteHandle != nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void CSqliteWrapper::Close()
{
    VERIFY(mSqliteHandle != nullptr);
    VERIFY(SQLITE_OK == sqlite3_close(mSqliteHandle));
    mSqliteHandle = nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void CSqliteWrapper::RunQuery(const std::string& query)
{
    VERIFY(mSqliteHandle != nullptr);
    VERIFY(SQLITE_OK == sqlite3_exec(mSqliteHandle, query.c_str(), nullptr, nullptr, nullptr));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
CSqliteWrapper::CStatement CSqliteWrapper::StartQuery(const std::string& query)
{
    VERIFY(mSqliteHandle != nullptr);
    sqlite3_stmt* statement;
    VERIFY(SQLITE_OK == sqlite3_prepare_v2(mSqliteHandle, query.c_str(), -1, &statement, 0));
    return statement;
}

